// Библиотека работы arduino с ИК приёмопередатчиками разработана интернет магазином http://iarduino.ru
// Примеры считывания данных с ИК-пульта и передачи данных через ИК-светодиод
// Для считывания данных с ИК-пульта предлагаем воспользоваться ИК-приёмником http://iarduino.ru/shop/Sensory-Datchiki/ik-priemnik-trema-modul.html

/*
Подключение библиотеки:
#include <iarduino_IR.h>
iarduino_IR IR(вывод ИК-приёмника [, вывод ИК-передатчика [, флаг инверсии сигнала для ИК-передатчика]]);
                                         если нет необходимости передавать сигналы (нет ИК-передатчика), то 2 и 3 параметры можно не указывать
                                         флаг инверсии сигнала для ИК передатчика по умолчанию равен false - без инверсии, то есть при отсутствии сигнала, на выводе для ИК передатчика устанавливается уровень логического «0»

В библиотеке реализованы 4 функции:
Функция begin     Назначение:            Инициализация ИК приёмопередатчика
                  Синтаксис:             begin();
                  Возвращаемые значения: Нет
                  Примечание:            Вызывается 1 раз в начале кода. Сама определяет нужна или нет инверсия сигнала от ИК датчика

Функция check     Назначение:            Определение и расшифровка принятых данных
                  Синтаксис:             check([ bool флаг_реагирования_на_сигналы_удержания_кнопки_пульта]);
                  Возвращаемые значения: bool true - при наличии принятого сигнала, или false при его отсутствии
                  Примечание:            После возврата true, данные можно прочитать из переменных - data, length, coding, frequency, data_repeat и length_repeat
                                         Флаг реагирования на сигналы удержания кнопки пульта по умолчанию равен false - не реагировать, то есть при удержании кнопки на пульте, функция вернет true только 1 раз, в момент нажатия
                                         Если указать параметр true, то функция будет возвращать true пока удерживается кнопка на пульте

Функция send      Назначение:            Отправка данных на ИК-светодиод (если его вывод указан при объявлении переменной IR)
                  Синтаксис:             send( uint32_t данные [, bool флаг_отправки_повторов]);
                  Возвращаемые значения: Нет
                  Примечание:            Флаг отправки повторов по умолчанию равен false - отправить только один информационный пакет
                                         Если указать флаг отправки повторов равный true, то функция подавляет дребезг при нажатии кнопки и отправляет пакеты повторов при её удержании
                                         Если не указан протокол передачи данных, то отправка происходит по последнему определённому функцией check протоколу передачи данных

Функция protocol  Назначение:            Установка/чтение/сброс протокола передачи данных (зависит от наличия и типа параметра функции)
                  Синтаксис:             protocol( char* "строка" );          - указание протокола в виде строки из 25 символов + символ конца строки
                  Синтаксис:             protocol();                          - чтение   протокола в виде строки из 25 символов + символ конца строки
                  Синтаксис:             protocol(false);                     - отмена ранее указанного протокола
                  Возвращаемые значения: При чтении протокола возвращается строка из 25 символов + символ конца строки
                  Примечание:            Если протокол читается,    то возвращаемая строка соответствует протоколу передачи последних успешно принятых функцией check данных
                                         Если протокол указывается, то дальнейшие действия приём/передача будут определяться указанным протоколом передачи данных
                  
Информация о строке протокола и переменных: data, length, coding, frequency, data_repeat и length_repeat описана в конце примера.
*/


//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА (ОДИН РАЗ ПРИ КАЖДОМ НАЖАТИИ КНОПКИ ПУЛЬТА)
#include <iarduino_IR.h>						// подключаем библиотеку для работы с ИК приёмопередатчиком
iarduino_IR IR(2);								// объявляем  переменную для работы с ИК приёмопередатчиком (номер цифрового вывода к которому подключён ИК приёмник = 2)

void setup(){
	Serial.begin(9600);                 	    // открываем последовательный порт на скорости 9600 бод
	IR.begin();									// инициализация ИК приёмопередатчика
}

void loop(){
	if(IR.check()){								// если принят информационный пакет
		Serial.println(IR.data,HEX);			// вывести данные на монитор
		Serial.println(IR.length);				// вывести размер данных на монитор (количество бит)
		Serial.println(IR.protocol());			// вывести строку с определённым протоколом передачи данных на монитор (25 символов)
	}
}


/*
//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА (ПОСТОЯННО, ПОКА УДЕРЖИВАЕТСЯ КНОПКА НА ПУЛЬТЕ) т.к. вызываем функцию check с параметром true
#include <iarduino_IR.h>						// подключаем библиотеку для работы с ИК приёмопередатчиком
iarduino_IR IR(2);								// объявляем  переменную для работы с ИК приёмопередатчиком (номер цифрового вывода к которому подключён ИК приёмник = 2)

void setup() {
	Serial.begin(9600);							// открываем последовательный порт на скорости 9600 бод
	IR.begin();									// инициализация ИК приёмопередатчика
}

void loop(){
	if(IR.check(true)){							// если принят информационный пакет или пакеты повтора
		Serial.println(IR.data,HEX);			// вывести данные на монитор
		Serial.println(IR.length);				// вывести размер данных на монитор (количество бит)
		Serial.println(IR.protocol());			// вывести строку с определённым протоколом передачи данных на монитор (25 символов)
	}
}
*/

/*
//	==============================================================================================
//	ЧИТАЕМ ДАННЫЕ С ПУЛЬТА ELENBERG (ИЛИ ЕМУ ПОДОБНЫХ) т.к. сами указываем протокол передачи данных функцией protocol
#include <iarduino_IR.h>						// подключаем библиотеку для работы с ИК приёмопередатчиком
iarduino_IR IR(2);								// объявляем  переменную для работы с ИК приёмопередатчиком (номер цифрового вывода к которому подключён ИК приёмник = 2)

void setup() {
	Serial.begin(9600);							// открываем последовательный порт на скорости 9600 бод
	IR.begin();									// инициализация ИК приёмопередатчика
	IR.protocol("AeQQV~zK]Kp^KJp[@@@@@@@Bp");	// указываем протокол передачи данных от пульта ELENBERG (25 символов)
}

void loop(){
	if(IR.check()){								// если принят информационный пакет с пультов использующих указанный протокол передачи данных
		Serial.println(IR.data,HEX);			// вывести данные о сигнале на монитор
	}											// функция check выполнит чтение данных быстрее чем в предыдущих примерах, т.к. ей уже не нужно определять протокол
}
*/

/*
//	==============================================================================================
//	ПЕРЕДАЁМ ДАННЫЕ НА ТЕЛЕВИЗОР ELENBERG (ИЛИ ЕМУ ПОДОБНЫЙ)
#include <iarduino_IR.h>						// подключаем библиотеку для работы с ИК приёмопередатчиком
iarduino_IR IR(2,3);							// объявляем  переменную для работы с ИК приёмопередатчиком (номера цифровых выводов к которым подключены: ИК приёмник = 2, ИК передатчик = 3)

void setup() {
	IR.begin();									// инициализация ИК приёмопередатчика
	pinMode(4, INPUT);							// 4 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(5, INPUT);							// 5 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(6, INPUT);							// 6 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	IR.protocol("AeQQV~zK]Kp^KJp[@@@@@@@Bp");	// указываем протокол передачи данных от пульта ELENBERG (25 символов)
}

void loop(){
	if(digitalRead(4)){IR.send(0x417,true);}	// отправляем сигнал ON/OFF (функция send вызвана с вторым параметром true следовательно она сама подавит дребезг кнопки)
	if(digitalRead(5)){IR.send(0x425,true);}	// отправляем сигнал VOL-
	if(digitalRead(6)){IR.send(0x427);}			// отправляем сигнал VOL+   (функция send вызвана без второго параметра следовательно команда будет отправляться при каждом цикле loop пока нажата кнопка)
												//                          (т.к. это команда VOL+, то громкость увеличится быстрее, чем при использовании второго параметра true.)
}
*/

/*
//	==============================================================================================
//	ПЕРЕДАЁМ ДАННЫЕ НА ТЕЛЕВИЗОР VESTEL (ИЛИ ЕМУ ПОДОБНЫЙ) И ЧИТАЕМ ДАННЫЕ С ЛЮБОГО ПУЛЬТА
#include <iarduino_IR.h>						// подключаем библиотеку для работы с ИК приёмопередатчиком
iarduino_IR IR(3,7);							// объявляем  переменную для работы с ИК приёмопередатчиком (номера цифровых выводов к которым подключены: ИК приёмник = 3, ИК передатчик = 7)

void setup() {
	Serial.begin(9600);							// открываем последовательный порт на скорости 9600 бод
	IR.begin();									// инициализация ИК приёмопередатчика
	pinMode(4, INPUT);							// 4 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(5, INPUT);							// 5 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
	pinMode(6, INPUT);							// 6 вывод arduino подключен к Vcc через кнопку и прижат к GND через резистор ~ 10...100 кОм
}

void loop(){
	IR.protocol("KdMM[TOcbdb@dQbP@@@@@D@B@");	// указываем протокол передачи данных от пульта VESTEL (25 символов)
	if(digitalRead(4)){IR.send(0x184C,true);}	// отправляем сигнал ON/OFF
	if(digitalRead(5)){IR.send(0x1851,true);}	// отправляем сигнал VOL-
	if(digitalRead(6)){IR.send(0x1850,true);}	// отправляем сигнал VOL+
	IR.protocol(false);							// отменяем ранее указанный протокол передачи данных
	if(IR.check()){								// если принят информационный пакет с любого пульта
		Serial.println(IR.data,HEX);			// вывести данные на монитор
	}
}
*/


/*
//                ==============================================================================================
Переменные:      Указанные переменные доступны для чтения после возврата true функцией check
coding           - кодировка                    (целое число от 0 до 63)
                   значение переменной можно сравнивать с константами:
                   coding==IR_UNDEFINED         тип кодирования не определён
                   coding==IR_PAUSE_LENGTH      кодирование длинной паузы
                   coding==IR_PULSE_LENGTH      кодирование шириной импульса (ШИМ)
                   coding==IR_ONE_PULSE_LENGTH  кодирование шириной одного импульса
                   coding==IR_BIPHASIC          бифазное кодирование
                   coding==IR_BIPHASIC_INV      бифазное кодирование с инверсными битами
                   coding==IR_NRC               NOKIA	бифазное кодирование с сигналом старт, пакеты повтора идентичны, первый и последний пакеты специальные
                   coding==IR_RS5               PHILIPS	бифазное кодирование с битом toggle (третий бит в пакете), пакеты повтора идентичны первому
                   coding==IR_RS5X              PHILIPS	бифазное кодирование с битом toggle (второй бит в пакете), пакеты повтора идентичны первому
                   coding==IR_RS6               PHILIPS	бифазное кодирование с битом toggle (пятый бит в пакете) и сигналом старт, пакеты повтора идентичны первому
frequency        - несущая частота в кГц        (целое число от 0 до 63)
                   данной переменной можно присвоить свою частоту передачи данных, это может увеличить радиус действия при передаче команд функцией send
                   если указать частоту 0 кГц, то функция send будет отправлять не модулированный сигнал
data             - принятые данные              (целое 32 битное число)  только для чтения
length           - количество принятых бит      (целое число от 0 до 32) только для чтения, позволяет отличить данные 0x00FF от данных 0xFF
data_repeat      - принятые данные из пакета повтора (целое 32 битное число) только для чтения
length_repeat    - количество принятых бит из пакета повтора (целое число от 0 до 32) только для чтения, позволяет отличить данные 0x00FF от данных 0xFF
key_press        - флаг сообщающий, что функция check вызванная с паретром rtue вернула положительный результат на информационный пакет данных, а не на пакеты повторов

Примечание:      Библиотека использует второй аппаратный таймер, не выводите сигналы ШИМ на 3 или 11 вывод.
                 Строка протокола передачи данных это 25 символов, каждый символ занимает 1 байт.
                   для того чтобы не завесить от кодировок и иметь возможность скопировать строку в скетч с монитора, я "пожертвовал" двумя первыми битами каждого символа, они всегда равны "01"
                   таким образом строка может состоять только из символов латинского алфавита и символов @[]{}\|^`_~
                   оставшиеся 6 бит каждого символа являются информационными и несут информацию о протоколе передачи данных:
                   - символы: 1=coding, 2=frequency, 3=length, 4=length_repeat, 12=позиции_бита_рестарт, 13=макс_длит_импульсов_(мкс/50), 14=мин_длит_импульсов_(мкс/50), 15=макс_длит_пауз_(мкс/50), 16=мин_длит_пауз_(мкс/50).                                                Старшие два бита равные "01" у этих символов заменяются на "00".
                   - символы: 5=длит_пауз_между_пакетами_(мс), 6=длит_импульса_старт_(мкс/50), 7=длит_паузы_старт_(мкс/50), 8=длит_импульса_стоп_(мкс/50), 9=длит_паузы_стоп_(мкс/50), 10=длит_импульса_рестарт_или_toggle_(мкс/50), 11=длит_паузы_рестарт_или_toggle_(мкс/50). Старшие два бита равные "01" у этих символов заменяются на два бита из символов 22,23,24.
                   - символы: 17=старшие_6_бит_пакета_повтора, 18=вторые_6_бит_пакета_повтора, 19=третие_6_бит_пакета_повтора, 20=четвёртые_6_бит_пакета_повтора, 21=пятые_6_бит_пакета_повтора, последние (младшие) 2 бита пакета повтора находятся в 22 символе.              Старшие два бита равные "01" у этих символов не учитываются.
                   - символы: 22,23,24 содержат по три пары бит для предыдущих символов, а символ 25 содержит флаги наличия сигналов старт, рестарт, toggle и стоп.
                 Переменная data (data_repeat) содержит все биты пакета, за исключением сигналов старт, стоп, рестарт и бита toggle.
                 Если сигнал старт (стоп) по своей форме идентичен биту 1 (0), то он расценивается как бит 1 (0) и включается в переменную data (data_repeat)
*/
